<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Create Test Recording</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            direction: rtl;
            text-align: right;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
            background: #3498db;
            color: white;
        }
        button:hover {
            background: #2980b9;
        }
        .info {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .success {
            background: #e8f5e8;
            color: #2e7d32;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>יצירת הקלטת בדיקה</h1>
        
        <div class="info">
            <strong>מטרה:</strong> ליצור הקלטת בדיקה ב-IndexedDB כדי לבדוק את פונקציונליות הנגן
        </div>

        <button onclick="createTestRecording()">צור הקלטת בדיקה</button>
        <button onclick="listRecordings()">הצג הקלטות קיימות</button>
        <button onclick="clearAllRecordings()">נקה את כל ההקלטות</button>
        
        <div id="status"></div>
        <div id="recordings"></div>
    </div>

    <script>
        function updateStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = type;
        }

        async function createTestRecording() {
            try {
                updateStatus('יוצר הקלטת בדיקה...', 'info');

                // Create a simple audio blob (1 second of silence)
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const sampleRate = audioContext.sampleRate;
                const duration = 2; // 2 seconds
                const frameCount = sampleRate * duration;
                
                const audioBuffer = audioContext.createBuffer(1, frameCount, sampleRate);
                const channelData = audioBuffer.getChannelData(0);
                
                // Generate a simple tone for testing
                for (let i = 0; i < frameCount; i++) {
                    channelData[i] = Math.sin(2 * Math.PI * 440 * i / sampleRate) * 0.1; // 440Hz tone at low volume
                }

                // Convert to WAV blob
                const wavBlob = audioBufferToWav(audioBuffer);
                
                // Create recording object
                const recording = {
                    id: `rec_${Date.now()}_test`,
                    filename: `test_recording_${new Date().toISOString().split('T')[0]}.wav`,
                    blob: wavBlob,
                    metadata: {
                        lessonName: 'הקלטת בדיקה',
                        subject: 'בדיקה',
                        classLevel: 'כיתה א',
                        curriculum: 'בדיקת מערכת',
                        originalFilename: `test_recording_${new Date().toISOString().split('T')[0]}.wav`,
                        fileSize: wavBlob.size,
                        mimeType: 'audio/wav',
                        createdAt: new Date().toISOString(),
                        duration: duration * 1000, // in milliseconds
                        qualityReport: {
                            overallQuality: 'good',
                            duration: duration * 1000,
                            sizeInMB: (wavBlob.size / 1024 / 1024).toFixed(2),
                            bitrate: 44100,
                            issues: [],
                            recommendations: []
                        }
                    }
                };

                // Store in IndexedDB
                await storeRecording(recording);
                
                updateStatus(`הקלטת בדיקה נוצרה בהצלחה! גודל: ${(wavBlob.size / 1024).toFixed(2)} KB`, 'success');
                
                // List recordings to verify
                await listRecordings();
                
            } catch (error) {
                console.error('Error creating test recording:', error);
                updateStatus(`שגיאה ביצירת הקלטת בדיקה: ${error.message}`, 'error');
            }
        }

        function audioBufferToWav(buffer) {
            const length = buffer.length;
            const arrayBuffer = new ArrayBuffer(44 + length * 2);
            const view = new DataView(arrayBuffer);
            const channelData = buffer.getChannelData(0);

            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };

            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, buffer.sampleRate, true);
            view.setUint32(28, buffer.sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, length * 2, true);

            // Convert float samples to 16-bit PCM
            let offset = 44;
            for (let i = 0; i < length; i++) {
                const sample = Math.max(-1, Math.min(1, channelData[i]));
                view.setInt16(offset, sample * 0x7FFF, true);
                offset += 2;
            }

            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }

        async function storeRecording(recording) {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('LimudAI_Recordings', 1);
                
                request.onerror = () => reject(request.error);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('recordings')) {
                        const store = db.createObjectStore('recordings', { keyPath: 'id' });
                        store.createIndex('createdAt', 'metadata.createdAt');
                        store.createIndex('filename', 'filename');
                    }
                };
                
                request.onsuccess = (event) => {
                    const db = event.target.result;
                    const transaction = db.transaction(['recordings'], 'readwrite');
                    const store = transaction.objectStore('recordings');
                    
                    const addRequest = store.add(recording);
                    
                    addRequest.onsuccess = () => resolve(recording.id);
                    addRequest.onerror = () => reject(addRequest.error);
                };
            });
        }

        async function listRecordings() {
            try {
                const recordings = await getRecordings();
                const recordingsDiv = document.getElementById('recordings');
                
                if (recordings.length === 0) {
                    recordingsDiv.innerHTML = '<div class="info">אין הקלטות במערכת</div>';
                    return;
                }

                let html = '<h3>הקלטות קיימות:</h3>';
                recordings.forEach(recording => {
                    html += `
                        <div class="info">
                            <strong>${recording.metadata?.lessonName || recording.filename}</strong><br>
                            ID: ${recording.id}<br>
                            גודל: ${(recording.metadata?.fileSize / 1024).toFixed(2)} KB<br>
                            תאריך: ${new Date(recording.metadata.createdAt).toLocaleString('he-IL')}<br>
                            משך: ${recording.metadata.duration}ms<br>
                            יש Blob: ${recording.blob ? 'כן' : 'לא'}
                        </div>
                    `;
                });
                
                recordingsDiv.innerHTML = html;
                
            } catch (error) {
                console.error('Error listing recordings:', error);
                updateStatus(`שגיאה בטעינת הקלטות: ${error.message}`, 'error');
            }
        }

        async function getRecordings() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('LimudAI_Recordings', 1);
                
                request.onerror = () => reject(request.error);
                
                request.onsuccess = (event) => {
                    const db = event.target.result;
                    const transaction = db.transaction(['recordings'], 'readonly');
                    const store = transaction.objectStore('recordings');
                    const getAllRequest = store.getAll();
                    
                    getAllRequest.onsuccess = () => resolve(getAllRequest.result);
                    getAllRequest.onerror = () => reject(getAllRequest.error);
                };
            });
        }

        async function clearAllRecordings() {
            if (!confirm('האם אתה בטוח שברצונך למחוק את כל ההקלטות?')) {
                return;
            }

            try {
                await new Promise((resolve, reject) => {
                    const request = indexedDB.open('LimudAI_Recordings', 1);
                    
                    request.onsuccess = (event) => {
                        const db = event.target.result;
                        const transaction = db.transaction(['recordings'], 'readwrite');
                        const store = transaction.objectStore('recordings');
                        const clearRequest = store.clear();
                        
                        clearRequest.onsuccess = () => resolve();
                        clearRequest.onerror = () => reject(clearRequest.error);
                    };
                });
                
                updateStatus('כל ההקלטות נמחקו בהצלחה', 'success');
                await listRecordings();
                
            } catch (error) {
                console.error('Error clearing recordings:', error);
                updateStatus(`שגיאה במחיקת הקלטות: ${error.message}`, 'error');
            }
        }

        // Load existing recordings on page load
        window.addEventListener('load', listRecordings);
    </script>
</body>
</html>
